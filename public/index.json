
[{"content":"","date":"14 July 2024","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":"","date":"14 July 2024","externalUrl":null,"permalink":"/tags/certification/","section":"Tags","summary":"","title":"Certification","type":"tags"},{"content":"","date":"14 July 2024","externalUrl":null,"permalink":"/tags/linux/","section":"Tags","summary":"","title":"Linux","type":"tags"},{"content":"","date":"14 July 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"14 July 2024","externalUrl":null,"permalink":"/tags/review/","section":"Tags","summary":"","title":"Review","type":"tags"},{"content":"在7/5號考完了RHCSA之後，忙著弄網站就忘記紀錄了\n簡單來說RHEL 8的版本跟RHEL 9的版本做起來並沒有差很多\n網路上目前一大堆RHEL 8題目，熟練以後沒有甚麼問題\n但我覺得最大的問題是container\n","date":"14 July 2024","externalUrl":null,"permalink":"/posts/rhcsa/","section":"Posts","summary":"","title":"RHCSA心得","type":"posts"},{"content":"","date":"14 July 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"\rMisc #\rWelcome #\r給新手一個見面禮\nAIS3{Welc0me_to_AIS3_PreExam_2o24!} Quantum Nim Heist #\r遊戲畫面如下: 在玩這個遊戲時，不要被規則侷限，不知道要怎麼解的話，多玩幾次就知道了 資安也是一樣的\nby 某個好心的AIS3 Staff （對不起我忘記你叫甚麼了；；）\n不要被規則侷限，我就想到，如果亂輸入數字會發生甚麼事\n所以玩一玩就開始打一些奇怪的數字，發現居然會略過自己的回合\n所以我直接打數字打到剩一個石頭就得到Flag了\nAIS3{Ar3_y0u_a_N1m_ma57er_0r_a_Crypt0_ma57er?} Three Dimensional Secret #\r解開以後是一個封包檔案\n說到封包，自然不能離開WireShark\n所以把這個檔案用WireShark看，然後找資料的部分，然後用TCP Stream\n就會看到一堆神奇的東西\n這題就跟 picoCTF的某題 大概相同\n所以同樣把他貼到NC viewer(G-code檢視的網站)上 就有Flag了！\nAIS3{b4d1y_tun3d_PriN73r} Web #\rEvil Calculator #\r直接點網址，進去以後長這樣 養成一個好習慣，看到Web按F12，發現了這個\n\u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;calculator-screen\u0026#34; id=\u0026#34;expression\u0026#34; placeholder=\u0026#34;0\u0026#34; disabled\u0026gt; 我的作法是把 disabled 改成 enable\n這樣計算機的螢幕就變成了我們可以輸入文字或指令的地方\n然後看source code，發現是flask框架，然後flag的路徑就在上層\n所以，直接在螢幕上打open(\u0026rsquo;../flag\u0026rsquo;).read()\n就直接噴出了Flag\nAIS3{7RiANG13_5NAK3_I5_50_3Vi1} Reverse #\rThe Long Print #\r解壓縮出來後，是一個執行檔，執行看看\n結果發現，好像甚麼都沒有發生？ 希望我們有足夠時間去收他的Flag？我才不要！\n所以我們可以直接用IDA pro或者Ghidra之類的靜態分析工具，分析看看他的程式\n這邊使用Ghidra分析，結果分析出來的Main函式如下\nundefined8 main(void) { uint local_14; int local_10; int local_c; puts(\u0026#34;Hope you have enough time to receive my flag:\u0026#34;); for (local_10 = 0; local_10 \u0026lt; 0x18; local_10 = local_10 + 2) { local_14 = *(uint *)(\u0026amp;key + (ulong)*(uint *)(secret + (long)(local_10 + 1) * 4) * 4) ^ *(uint *)(secret + (long)local_10 * 4); for (local_c = 0; local_c \u0026lt; 4; local_c = local_c + 1) { sleep(0x3674); printf(\u0026#34;%c\u0026#34;,(ulong)local_14); local_14 = local_14 \u0026gt;\u0026gt; 8; fflush(stdout); } } puts(\u0026#34;\\rOops! Where is the flag? I am sure that the flag is already printed!\u0026#34;); return 0; } 在第13行可以看到，他會進行0x3674秒的sleep，大概是3.872小時，太久了！\n所以我們可以直接修改他的數值，直接利用Ghidra的Patch Instruction功能去修改他！\n把上圖的0x3674修改成0x1之類的數字，之後sleep就變成了1秒！ 然後匯出之後執行檔案，沒多久就可以執行出Flag了！ AIS3{You_are_the_master_of_time_management!!!!?}\n火拳のエース #\r跟上題一樣，解壓縮之後，看看題目執行的樣子 結果出現如下圖： 然後打開Ghidra跑分析，接下來看到main函式\nundefined4 main(void) { char cVar1; uint __seed; int iVar2; int local_14; __seed = time((time_t *)0x0); srand(__seed); buffer0 = (char *)malloc(9); buffer1 = (char *)malloc(9); buffer2 = (char *)malloc(9); buffer3 = (char *)malloc(9); memset(buffer0,0,9); memset(buffer1,0,9); memset(buffer2,0,9); memset(buffer3,0,9); print_flag(); __isoc99_scanf(\u0026#34;%8s %8s %8s %8s\u0026#34;,buffer0,buffer1,buffer2,buffer3); xor_strings(buffer0,\u0026amp;DAT_0804a163,buffer0); xor_strings(buffer1,\u0026amp;DAT_0804a16c,buffer1); xor_strings(buffer2,\u0026amp;DAT_0804a175,buffer2); xor_strings(buffer3,\u0026amp;DAT_0804a17e,buffer3); for (local_14 = 0; local_14 \u0026lt; 8; local_14 = local_14 + 1) { cVar1 = complex_function((int)buffer0[local_14],local_14); buffer0[local_14] = cVar1; cVar1 = complex_function((int)buffer1[local_14],local_14 + 0x20); buffer1[local_14] = cVar1; cVar1 = complex_function((int)buffer2[local_14],local_14 + 0x40); buffer2[local_14] = cVar1; cVar1 = complex_function((int)buffer3[local_14],local_14 + 0x60); buffer3[local_14] = cVar1; } iVar2 = strncmp(buffer0,\u0026#34;DHLIYJEG\u0026#34;,8); if (iVar2 == 0) { iVar2 = strncmp(buffer1,\u0026#34;MZRERYND\u0026#34;,8); if (iVar2 == 0) { iVar2 = strncmp(buffer2,\u0026#34;RUYODBAH\u0026#34;,8); if (iVar2 == 0) { iVar2 = strncmp(buffer3,\u0026#34;BKEMPBRE\u0026#34;,8); if (iVar2 == 0) { puts(\u0026#34;Yes! I remember now, this is it!\u0026#34;); goto LAB_08049869; } } } } puts(\u0026#34;It feels slightly wrong, but almost correct...\u0026#34;); LAB_08049869: free(buffer0); free(buffer1); free(buffer2); free(buffer3); return 0; } 可以看到，Flag剩下的部分是先由xor加密過後再用complex_function去再次加密\n之後的四個字串就是\u0026quot;DHLIYJEG\u0026quot;,\u0026ldquo;MZRERYND\u0026rdquo;,\u0026ldquo;RUYODBAH\u0026rdquo;,\u0026ldquo;BKEMPBRE\u0026rdquo;\n然後可以看看complex_function\nint complex_function(int param_1,int param_2) { int iVar1; int local_10; if ((0x40 \u0026lt; param_1) \u0026amp;\u0026amp; (param_1 \u0026lt; 0x5b)) { local_10 = (param_1 + -0x41 + param_2 * 0x11) % 0x1a; iVar1 = param_2 % 3 + 3; param_2 = param_2 % 3; if (param_2 == 2) { local_10 = ((local_10 - iVar1) + 0x1a) % 0x1a; } else if (param_2 \u0026lt; 3) { if (param_2 == 0) { local_10 = (local_10 * iVar1 + 7) % 0x1a; } else if (param_2 == 1) { local_10 = (iVar1 * 2 + local_10) % 0x1a; } } return local_10 + 0x41; } puts(\u0026#34;It feels slightly wrong, but almost correct...\u0026#34;); /* WARNING: Subroutine does not return */ exit(1); } 我的作法是直接寫程式去對照\n解密出來的結果再拿回去xor\n程式如下！\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; using namespace std; void xor_strings(char *str, unsigned char *key, int len) { for (int i = 0; i \u0026lt; len; i++) { str[i] = str[i] ^ key[i]; } } int complex_function(int param_1, int param_2) { int iVar1; int local_10; if ((0x40 \u0026lt; param_1) \u0026amp;\u0026amp; (param_1 \u0026lt; 0x5b)) { local_10 = (param_1 - 0x41 + param_2 * 0x11) % 0x1a; iVar1 = param_2 % 3 + 3; param_2 = param_2 % 3; if (param_2 == 2) { local_10 = ((local_10 - iVar1) + 0x1a) % 0x1a; } else if (param_2 \u0026lt; 3) { if (param_2 == 0) { local_10 = (local_10 * iVar1 + 7) % 0x1a; } else if (param_2 == 1) { local_10 = (iVar1 * 2 + local_10) % 0x1a; } } return local_10 + 0x41; } printf(\u0026#34;It feels slightly wrong, but almost correct...\\n\u0026#34;); return 0; } void decrypt(char a[], int b) { char ans[26]; for (int i = 0; i \u0026lt; 26; i++) { ans[i] = \u0026#39;A\u0026#39; + i; } for (int i = 0; i \u0026lt; 8; i++) { for (int j = 0; j \u0026lt; 26; j++) { char cVal = complex_function(65 + j, i + b); if (cVal == a[i]) { a[i] = ans[j]; break; // Once found, no need to continue the loop } } } } int main() { char str1[] = \u0026#34;DHLIYJEG\u0026#34;; char str2[] = \u0026#34;MZRERYND\u0026#34;; char str3[] = \u0026#34;RUYODBAH\u0026#34;; char str4[] = \u0026#34;BKEMPBRE\u0026#34;; decrypt(str1, 0); decrypt(str2, 0x20); decrypt(str3, 0x40); decrypt(str4, 0x60); unsigned char key1[] = {0x0e, 0x0d, 0x7d, 0x06, 0x0f, 0x17, 0x76, 0x04}; unsigned char key2[] = {0x6d, 0x00, 0x1b, 0x7c, 0x6c, 0x13, 0x62, 0x11}; unsigned char key3[] = {0x1e, 0x7e, 0x06, 0x13, 0x07, 0x66, 0x0e, 0x71}; unsigned char key4[] = {0x17, 0x14, 0x1d, 0x70, 0x79, 0x67, 0x74, 0x33}; xor_strings(str1, key1, 8); xor_strings(str2, key2, 8); xor_strings(str3, key3, 8); xor_strings(str4, key4, 8); printf(\u0026#34;Result: %s%s%s%s\u0026#34;, str1,str2,str3,str4); return 0; } 之後解密完拿回去，它印出Yes! I remember now, this is it!\n就是Flag了！\n（如果覺得它剛開始的字串跑太慢可以修改print_flag函式裡，local_10的值）\n注意它印出來的G0D是0，不是O\nAIS3{G0D_D4MN_4N9R_15_5UP3R_P0W3RFU1!!!} Crypto #\rbabyRSA #\r![image](https://hackmd.io/_uploads/HJMC5Q7NA.png =50%x)\n先打開來看看程式！\n# babyRSA.py import random from Crypto.Util.number import getPrime from secret import flag def gcd(a, b): while b: a, b = b, a % b return a def generate_keypair(keysize): p = getPrime(keysize) q = getPrime(keysize) n = p * q phi = (p-1) * (q-1) e = random.randrange(1, phi) g = gcd(e, phi) while g != 1: e = random.randrange(1, phi) g = gcd(e, phi) d = pow(e, -1, phi) return ((e, n), (d, n)) def encrypt(pk, plaintext): key, n = pk cipher = [pow(ord(char), key, n) for char in plaintext] return cipher def decrypt(pk, ciphertext): key, n = pk plain = [chr(pow(char, key, n)) for char in ciphertext] return \u0026#39;\u0026#39;.join(plain) public, private = generate_keypair(512) encrypted_msg = encrypt(public, flag) decrypted_msg = decrypt(private, encrypted_msg) print(\u0026#34;Public Key:\u0026#34;, public) print(\u0026#34;Encrypted:\u0026#34;, encrypted_msg) # print(\u0026#34;Decrypted:\u0026#34;, decrypted_msg) output.txt有給我們public key跟加密過後的訊息\n原本是想說，可以算算看private key，但後來發現數字太大了不可能\n而且最要命的是Github上也有這個工具\n後來覺得算太慢了，直接用python建立字典然後自動轉換\nimport string public_key = #(公鑰) def encrypt_with_known_key(public_key, plaintext): key, n = public_key cipher = [pow(ord(char), key, n) for char in plaintext] return cipher all_characters = string.ascii_letters + string.digits + string.punctuation + string.whitespace encrypted_dict = {char: encrypt_with_known_key(public_key, char)[0] for char in all_characters} def decrypt_with_dict(encrypted_list, encrypted_dict): reversed_dict = {value: key for key, value in encrypted_dict.items()} decrypted_text = \u0026#39;\u0026#39;.join(reversed_dict[enc_char] for enc_char in encrypted_list) return decrypted_text encrypted_list = #[加密內容] decrypted_text = decrypt_with_dict(encrypted_list, encrypted_dict) print(\u0026#34;Decrypted Text:\u0026#34;, decrypted_text) AIS3{NeverUseTheCryptographyLibraryImplementedYourSelf} Pwn #\r對不起，我不會；；\n","date":"13 July 2024","externalUrl":null,"permalink":"/posts/ais3-pre-exam-2024/","section":"Posts","summary":"","title":"AIS3 Pre-Exam\u0026MyfirstCTF 2024 Write-up","type":"posts"},{"content":"","date":"13 July 2024","externalUrl":null,"permalink":"/tags/ctf/","section":"Tags","summary":"","title":"CTF","type":"tags"},{"content":"","date":"13 July 2024","externalUrl":null,"permalink":"/tags/cyber-security/","section":"Tags","summary":"","title":"Cyber Security","type":"tags"},{"content":"","date":"13 July 2024","externalUrl":null,"permalink":"/tags/write-up/","section":"Tags","summary":"","title":"Write-Up","type":"tags"},{"content":"","date":"13 July 2024","externalUrl":null,"permalink":"/tags/hugo/","section":"Tags","summary":"","title":"Hugo","type":"tags"},{"content":"其實只是測試貼文，筆記只是順便\n說好的網站，弄了很久終於下定決心要弄好了\n原本是想要用Hexo來架，結果不小心就被Hugo燒到ㄌ\n網路上有很多大神的Hugo介紹，或者有Blowfish Theme的文件可以參考\n在local端運行網頁\nhugo server 然後\u0026hellip;好像也沒有然後ㄌ\n","date":"13 July 2024","externalUrl":null,"permalink":"/posts/hugo-notes/","section":"Posts","summary":"","title":"hugo筆記","type":"posts"},{"content":"","date":"13 July 2024","externalUrl":null,"permalink":"/tags/notes/","section":"Tags","summary":"","title":"Notes","type":"tags"},{"content":"","date":"13 July 2024","externalUrl":null,"permalink":"/tags/website/","section":"Tags","summary":"","title":"Website","type":"tags"},{"content":"嗨，我是hsuan0223x(h大小寫都可)，你可以叫我鯊鯊\n目前在臺北商業大學中就讀資訊管理系 期待自己能活躍在各項資訊活動、競賽中\n在貼文中如果有錯誤的地方，可以利用主頁的聯繫方式與我聯繫！\n證照 #\r證照名稱 等級 單位 電腦硬體裝修 丙級技術士 勞動部勞動力發展署技能檢定中心 Red Hat Certified System Administrator Red Hat 活動\u0026amp;議程參與 #\r活動名稱 時間 職位 地點 2023 IThome 鐵人賽 2023 選手 Link SITCON學⽣計算機年會 2024 會眾 中央研究院 人文社會科學館 Cybersec 臺灣資安大會 2024 會眾 南港展覽館二館 競賽經歷 #\r競賽名稱 時間 類型 成績 51屆分區技能競賽 2022 網路技術 HP CodeWars 2023 競技程式 54屆分區技能競賽 2024 網路技術 佳作 AI Junior Award 2024 2024 創新競賽 AIS3 MyfirstCTF 2024 資訊安全 20th AIS3 pre-exam 2024 資訊安全 95th 專題研討\u0026amp;參與課程 #\r名稱 時間 地點 Linux 常用服務知識、觀念及架設 2022/11~2022/12 國立臺北商業大學 Linux 故障排除 2023/3~2023/7 國立臺北商業大學 全面解析HTTPS，讓你真正搞懂它 2024/5/23、2024/5/24 國立臺北商業大學 ","date":"12 July 2024","externalUrl":null,"permalink":"/about/","section":"","summary":"","title":"Who am I?","type":"page"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]